Bac <- subset_taxa(PS.TSS, Kingdom %in%"Bacteria")

Bac

############# First create dyad data#######################
key <- data.frame(ID=sample_data(Bac)$Mouse_ID)
metadt <- sample_data(Bac)


####################
## 1) Jaccard distance
JACM <- as.matrix(phyloseq::distance(Bac, method="jaccard", type="samples"))
# transpose Jaccard disssimilary matrix to Jaccard similarty matrix
JACM <- 1-JACM
# sanity check
all(rownames(JACM)==key)
dimnames(JACM)<- c(key, key)

## 2) Spatial distance matrix
distance.df <- metadt[,c("Mouse_ID", "Longitude", "Latitude")]
SPATM <- array(NA, c(length(distance.df$Mouse_ID),length(distance.df$Mouse_ID)))
# derive matrix with spatial distances between each location
for (i in 1:length(distance.df$Mouse_ID)){
    for (j in 1:length(distance.df$Mouse_ID))
    {SPATM[i,j]= sqrt((abs(distance.df$Longitude[i]-distance.df$Longitude[j]))^2+
                      (abs(distance.df$Latitude[i]-distance.df$Latitude[j]))^2)
    }
}
dimnames(SPATM)<- c(key, key)

# 3) pairwise genetic distance based on genetic data
# I actually need to get this from sota again
sota <- read.csv("https://raw.githubusercontent.com/derele/Mouse_Eimeria_Field/master/data_products/SOTA_Data_Product.csv")
gen <- c("mtBamH", "YNPAR", "X332", "X347", "X65", "Tsx", "Btk", "Syap1",
         "Es1","Gpd1","Idh1","Mpi","Np", "Sod1", "Es1C", "Gpd1C", "Idh1C",
         "MpiC","NpC", "Sod1C")
sota <- sota[sota$Mouse_ID%in%distance.df$Mouse_ID,c("Mouse_ID", gen)]
sota <- sota[match(distance.df$Mouse_ID, sota$Mouse_ID),]
all(sota$Mouse_ID==distance.df$Mouse_ID)
rownames(sota) <- sota$Mouse_ID
sota$Mouse_ID <- NULL
gen.dis <- dist.gene(sota, method = "pairwise", pairwise.deletion = TRUE)
gen.dis <- as.matrix(gen.dis)
dimnames(gen.dis) <- c(key, key)

## 3) Sex pairs
Sex_frame<-metadt[,c("Mouse_ID","Sex")]
Sex_frame$Mouse_ID<-as.character(Sex_frame$Mouse_ID)
Sex_frame$Sex<-as.character(Sex_frame$Sex)
#Create an empty character matrix to fill with characters
SEXM<-array(as.character(NA),c(nrow(Sex_frame),nrow(Sex_frame)))

for(i in 1:nrow(Sex_frame)){
    for(j in 1:nrow(Sex_frame)){
        if(Sex_frame$Sex[i]=="F" & Sex_frame$Sex[i]==Sex_frame$Sex[j]){
            SEXM[i,j]= "FF"}
        if(Sex_frame$Sex[i]=="M" & Sex_frame$Sex[i]==Sex_frame$Sex[j]){
           SEXM[i,j]= "MM"}
        if( Sex_frame$Sex[i]!=Sex_frame$Sex[j]){
            SEXM[i,j]= "FM"}
    }
}
dimnames(SEXM)<-c(key, key)

# 4) Making BMI distances
#Create data frame with each sample name (character) and sampling time (numeric)
BMI_frame<-metadt[,c("Mouse_ID", "BMI")]
#Create an empty matrix to fill with distances
BMIM<-array(0,c(nrow(BMI_frame),nrow(BMI_frame)))
#Derive matrix with time distances between each sample using abs()-function
for (i in 1:nrow(BMI_frame)){
    for (j in 1:nrow(BMI_frame))
    {BMIM[i,j]=abs(BMI_frame$BMI[i] -BMI_frame$BMI[j])
    }
}
dimnames(BMIM) <- c(key, key)

# 6) Create farm/Locality matrix: 
#Create data frame with each Individual name (character) and their Age (Character)
Loc_frame<-metadt[,c("Mouse_ID","Locality")]
#Create an empty numeric matrix to fill with distances
LocM<-array(0,c(nrow(Loc_frame),nrow(Loc_frame)))
#Derive matrix with binary locality similarity between each sample
for(i in 1:nrow(Loc_frame)){
    for(j in 1:nrow(Loc_frame)){
        if(Loc_frame$Locality[i]==Loc_frame$Locality[j]){
            LocM[i,j]= "1"
        } else{
            LocM[i,j]= "0"
        }
    }
}
#Note that Locality similarity matrix has rownames and colnames in the same order as key
all(rownames(LocM)==key$ID)
dimnames(LocM) <- c(key, key)


# 6) this matrix will describe the distance in years between samples
#Transform dates into a numeric variable
metadt$Year <- as.numeric(metadt$Year)
#Create data frame with each sample name (character) and sampling time (numeric)
SampleTime_frame<-metadt[,c("Mouse_ID","Year")]
#Create an empty matrix to fill with distances
TEMPM<-array(0,c(nrow(SampleTime_frame),nrow(SampleTime_frame)))
#Derive matrix with time distances between each sample using abs()-function
for (i in 1:nrow(SampleTime_frame)){
 for (j in 1:nrow(SampleTime_frame))
{TEMPM[i,j]=abs(SampleTime_frame$Year[i] -SampleTime_frame$Year[j])
  }
}
dimnames(TEMPM)<-c(key,key)

# 7) Making HI distances
#Create data frame with each sample name (character) and sampling time (numeric)
HI_frame<-metadt[,c("Mouse_ID", "HI")]
#Create an empty matrix to fill with distances
HIM<-array(0,c(nrow(HI_frame),nrow(HI_frame)))
#Derive matrix with time distances between each sample using abs()-function
for (i in 1:nrow(HI_frame)){
    for (j in 1:nrow(HI_frame))
    {HIM[i,j]=abs(HI_frame$HI[i] -HI_frame$HI[j])
    }
}
dimnames(HIM) <- c(key, key)

# 7) Making hi distances
#Create data frame with each sample name (character) and sampling time (numeric)
hi_frame<-metadt[,c("Mouse_ID", "hi")]
#Create an empty matrix to fill with distances
hiM<-array(0,c(nrow(hi_frame),nrow(hi_frame)))
#Derive matrix with time distances between each sample using abs()-function
for (i in 1:nrow(hi_frame)){
    for (j in 1:nrow(hi_frame))
    {hiM[i,j]=abs(hi_frame$hi[i] -hi_frame$hi[j])
    }
}
dimnames(hiM) <- c(key, key)


# here are our matrices
str(BMIM)
str(SPATM)
str(JACM)
str(gen.dis)
str(SEXM)
str(LocM)
str(HIM)
str(hiM)
str(TEMPM)
#First unravel the matrices into vectors matching the lower quantile of each matrix.

#From numeric matrices, this can be done by making a list (c()) of the distance object (dist()) derived from the matrix. as.dist() by default includes only the lower quantile of the matrix and excludes the diagonal.
#From categorical matrices, this can be done by making a list (c()) of the lower quantile of the matrix with lower.tri() -function.

jac<-c(as.dist(JACM))
bmi<-c(as.dist(BMIM))
spa<-c(as.dist(SPATM))
gen<-c(as.dist(gen.dis))
sex<-c(SEXM[lower.tri(SEXM)])
loc <- as.character(c(as.dist(LocM)))
HIm <- c(as.dist(HIM))
him <- c(as.dist(hiM))
tempm <- c(as.dist(TEMPM))

#Combine these vectors into a data frame
data.dyad<-data.frame(BMI=bmi,Microbiome_similarity=jac,spatial=spa, genetic_dist=gen, locality=loc, HI=HIm, year=tempm, hi=him, sex=sex)

data.dyad$locality <- as.factor(data.dyad$locality)

#Now all we need to do is add the identities of both individuals in each dyad as separate columns into the data frame and exclude self-comparisons (as these are not meaningful).

# extracting Individual-combinations present in the matrices
list<-expand.grid(key$ID, key$ID)

str(list)

# This created individual-to-same-individual pairs as well. Get rid of these:
list<-list[which(list$Var1!=list$Var2),]

# this still has both quantiles in--> add 'unique' key
list$key <- apply(list, 1, function(x)paste(sort(x), collapse=''))
list<-subset(list, !duplicated(list$key))

# sanity check that the Individual name combinations are in the same exact order as the lower quantile value vector of the matrices
i=nrow(key)
JACM[which(rownames(JACM)==list$Var1[i]),which(colnames(JACM)==list$Var2[i])]==jac[i]

# add the names of both individuals participating in each dyad into the data frame
data.dyad$IDA<-list$Var2
data.dyad$IDB<-list$Var1
# Make sure you have got rid of all self comparisons
data.dyad<-data.dyad[which(data.dyad$IDA!=data.dyad$IDB),]


######################### Now we model the data ####################

## sex combination into a factor
data.dyad$sex <- factor(data.dyad$sex, levels=c("MM", "FM", "FF"))

#scale all predictors to range between 0-1 if they are not already naturally on that scale
#define scaling function:
range.use <- function(x,min.use,max.use){ (x - min(x,na.rm=T))/(max(x,na.rm=T)-min(x,na.rm=T)) * (max.use - min.use) + min.use }
scalecols<-c("spatial","genetic_dist", "BMI", "year", "hi")
for(i in 1:ncol(data.dyad[,which(colnames(data.dyad)%in%scalecols)])){
    data.dyad[,which(colnames(data.dyad)%in%scalecols)][,i]<-range.use(data.dyad[,which(colnames(data.dyad)%in%scalecols)][,i],0,1)
    }

#saveRDS(data.dyad, "tmp/data.dyad.RDS")
#data.dyad <- readRDS("tmp/data.dyad.RDS")

#hist(data.dyad$Microbiome_similarity)
# proportional values semi-normally distributed limited between 0 and 1 not including 1 and 0 --> best use betaregression, but gaussian would probably give similar estimates

## now let's take a look at correlation trends

## now let's take a look at correlation trends
preplot1<-ggplot(data = data.dyad, aes(x= Microbiome_similarity, y= year))+
    geom_point(size= 1.2, alpha= .8, position= "jitter")+
    geom_smooth(method= lm, se= FALSE, col= "red", size= .5, alpha= .8)+
    theme_bw()
preplot1

preplot2<-ggplot(data = data.dyad, aes(x= Microbiome_similarity, y= BMI))+
    geom_point(size= 1.2, alpha= .8, position= "jitter")+
    geom_smooth(method= lm, se= FALSE, col= "red", size= .5, alpha= .8)+
    theme_bw()
preplot2

preplot3<-ggplot(data = data.dyad, aes(x= Microbiome_similarity, y= Parasite))+
    geom_point(size= 1.2, alpha= .8, position= "jitter")+
    geom_smooth(method= lm, se= FALSE, col= "red", size= .5, alpha= .8)+
    theme_bw()
preplot3

preplot4<-ggplot(data = data.dyad, aes(x= Microbiome_similarity, y= genetic_dist))+
    geom_point(size= 1.2, alpha= .8, position= "jitter", aes(fill=sex))+
    geom_smooth(method= lm, se= FALSE, col= "red", size= .8, aes(col=sex))+
    facet_wrap(~sex)+
    theme_bw()
preplot4


#model1_bac<-brm(Microbiome_similarity~1+ spatial+locality+genetic_dist*hi+year+BMI+sex+
#                (1|mm(IDA,IDB)),
#                data = data.dyad,
#                family= "gaussian",
#                warmup = 1000, iter = 3000,
#                cores = 20, chains = 4,
#               inits=0)
#saveRDS(model1_bac, "tmp/BRMmodel1_bac.rds")

model1_bac

remove.packages('ggthemes')

############## Parasites

Parasite <- subset_taxa(PS.TSS, Genus %in%c("Eimeria", "Cryptosporidium", "Syphacia", "Aspiculuris", "Ascaridida", "Mastophorus","Trichuris", "Hymenolepis", "Tritrichomonas"))

all(key == data.frame(ID=sample_data(Parasite)$Mouse_ID))

####################
## 1) Jaccard distance
JACM <- as.matrix(phyloseq::distance(Parasite, method="jaccard", type="samples"))
# transpose Jaccard disssimilary matrix to Jaccard similarty matrix
JACM <- 1-JACM
# sanity check
all(rownames(JACM)==key)
dimnames(JACM)<- c(key, key)

jac<-c(as.dist(JACM))

#Combine these vectors into a data frame
data.dyad<-data.frame(BMI=bmi,Microbiome_similarity=jac,spatial=spa, genetic_dist=gen, locality=loc, HI=HIm, year=tempm, hi=him, sex=sex)

data.dyad$locality <- as.factor(data.dyad$locality)

#Now all we need to do is add the identities of both individuals in each dyad as separate columns into the data frame and exclude self-comparisons (as these are not meaningful).

# extracting Individual-combinations present in the matrices
list<-expand.grid(key$ID, key$ID)

# This created individual-to-same-individual pairs as well. Get rid of these:
list<-list[which(list$Var1!=list$Var2),]

# this still has both quantiles in--> add 'unique' key
list$key <- apply(list, 1, function(x)paste(sort(x), collapse=''))
list<-subset(list, !duplicated(list$key))

# sanity check that the Individual name combinations are in the same exact order as the lower quantile value vector of the matrices
i=nrow(key)
JACM[which(rownames(JACM)==list$Var1[i]),which(colnames(JACM)==list$Var2[i])]==jac[i]

# add the names of both individuals participating in each dyad into the data frame
data.dyad$IDA<-list$Var2
data.dyad$IDB<-list$Var1
# Make sure you have got rid of all self comparisons
data.dyad<-data.dyad[which(data.dyad$IDA!=data.dyad$IDB),]


######################### Now we model the data ####################

## sex combination into a factor
data.dyad$sex <- factor(data.dyad$sex, levels=c("MM", "FM", "FF"))

#scale all predictors to range between 0-1 if they are not already naturally on that scale
#define scaling function:
range.use <- function(x,min.use,max.use){ (x - min(x,na.rm=T))/(max(x,na.rm=T)-min(x,na.rm=T)) * (max.use - min.use) + min.use }
scalecols<-c("spatial","genetic_dist", "BMI", "year", "hi")
for(i in 1:ncol(data.dyad[,which(colnames(data.dyad)%in%scalecols)])){
    data.dyad[,which(colnames(data.dyad)%in%scalecols)][,i]<-range.use(data.dyad[,which(colnames(data.dyad)%in%scalecols)][,i],0,1)
    }

#saveRDS(data.dyad, "tmp/data.dyad.RDS")
#data.dyad <- readRDS("tmp/data.dyad.RDS")

#hist(data.dyad$Microbiome_similarity)
# proportional values semi-normally distributed limited between 0 and 1 not including 1 and 0 --> best use betaregression, but gaussian would probably give similar estimates

## now let's take a look at correlation trends

#model1_para<-brm(Microbiome_similarity~1+ spatial+locality+genetic_dist*hi+year+BMI+sex+
#                (1|mm(IDA,IDB)),
#                data = data.dyad,
#                family= "gaussian",
#                warmup = 1000, iter = 3000,
#                cores = 20, chains = 4,
#               inits=0)
#saveRDS(model1_para, "tmp/BRMmodel1_para.rds")


####### Diet
Diet <- subset_taxa(PS.TSS, Phylum %in% c("Anthophyta", "Phragmoplastophyta", "Charophyta", "Ochrophyta"))
####################
## 1) Jaccard distance
JACM <- as.matrix(phyloseq::distance(Diet, method="jaccard", type="samples"))
# transpose Jaccard disssimilary matrix to Jaccard similarty matrix
JACM <- 1-JACM
# sanity check
all(rownames(JACM)==key)
dimnames(JACM)<- c(key, key)
jac<-c(as.dist(JACM))
#Combine these vectors into a data frame
data.dyad<-data.frame(BMI=bmi,Microbiome_similarity=jac,spatial=spa, genetic_dist=gen, locality=loc, HI=HIm, year=tempm, hi=him, sex=sex)
data.dyad$locality <- as.factor(data.dyad$locality)
list<-expand.grid(key$ID, key$ID)
list<-list[which(list$Var1!=list$Var2),]
list$key <- apply(list, 1, function(x)paste(sort(x), collapse=''))
list<-subset(list, !duplicated(list$key))
i=nrow(key)
JACM[which(rownames(JACM)==list$Var1[i]),which(colnames(JACM)==list$Var2[i])]==jac[i]
data.dyad$IDA<-list$Var2
data.dyad$IDB<-list$Var1
data.dyad<-data.dyad[which(data.dyad$IDA!=data.dyad$IDB),]
######################### Now we model the data ####################
data.dyad$sex <- factor(data.dyad$sex, levels=c("MM", "FM", "FF"))
range.use <- function(x,min.use,max.use){ (x - min(x,na.rm=T))/(max(x,na.rm=T)-min(x,na.rm=T)) * (max.use - min.use) + min.use }
scalecols<-c("spatial","genetic_dist", "BMI", "year", "hi")
for(i in 1:ncol(data.dyad[,which(colnames(data.dyad)%in%scalecols)])){
    data.dyad[,which(colnames(data.dyad)%in%scalecols)][,i]<-range.use(data.dyad[,which(colnames(data.dyad)%in%scalecols)][,i],0,1)
    }
#model1_diet<-brm(Microbiome_similarity~1+ spatial+locality+genetic_dist*hi+year+BMI+sex+
#                (1|mm(IDA,IDB)),
#                data = data.dyad,
#                family= "gaussian",
#                warmup = 1000, iter = 3000,
#                cores = 20, chains = 4,
#               inits=0)
#saveRDS(model1_diet, "tmp/BRMmodel1_diet.rds")

####### Fungi
Fungi <- subset_taxa(PS.TSS, Phylum %in% c("Mucoromycota", "Ascomycota", "Basidiomycota"))
####################
## 1) Jaccard distance
JACM <- as.matrix(phyloseq::distance(Fungi, method="jaccard", type="samples"))
# transpose Jaccard disssimilary matrix to Jaccard similarty matrix
JACM <- 1-JACM
# sanity check
all(rownames(JACM)==key)
dimnames(JACM)<- c(key, key)
jac<-c(as.dist(JACM))
#Combine these vectors into a data frame
data.dyad<-data.frame(BMI=bmi,Microbiome_similarity=jac,spatial=spa, genetic_dist=gen, locality=loc, HI=HIm, year=tempm, hi=him, sex=sex)
data.dyad$locality <- as.factor(data.dyad$locality)
list<-expand.grid(key$ID, key$ID)
list<-list[which(list$Var1!=list$Var2),]
list$key <- apply(list, 1, function(x)paste(sort(x), collapse=''))
list<-subset(list, !duplicated(list$key))
i=nrow(key)
JACM[which(rownames(JACM)==list$Var1[i]),which(colnames(JACM)==list$Var2[i])]==jac[i]
data.dyad$IDA<-list$Var2
data.dyad$IDB<-list$Var1
data.dyad<-data.dyad[which(data.dyad$IDA!=data.dyad$IDB),]
######################### Now we model the data ####################
data.dyad$sex <- factor(data.dyad$sex, levels=c("MM", "FM", "FF"))
range.use <- function(x,min.use,max.use){ (x - min(x,na.rm=T))/(max(x,na.rm=T)-min(x,na.rm=T)) * (max.use - min.use) + min.use }
scalecols<-c("spatial","genetic_dist", "BMI", "year", "hi")
for(i in 1:ncol(data.dyad[,which(colnames(data.dyad)%in%scalecols)])){
    data.dyad[,which(colnames(data.dyad)%in%scalecols)][,i]<-range.use(data.dyad[,which(colnames(data.dyad)%in%scalecols)][,i],0,1)
    }
#model1_Fungi<-brm(Microbiome_similarity~1+ spatial+locality+genetic_dist*hi+year+BMI+sex+
#                (1|mm(IDA,IDB)),
#                data = data.dyad,
#                family= "gaussian",
#                warmup = 1000, iter = 3000,
#                cores = 20, chains = 4,
#               inits=0)
#saveRDS(model1_Fungi, "tmp/BRMmodel1_Fungi.rds")


### uploading models
model1_para <- readRDS("tmp/BRMmodel1_para.rds")
model1_Fungi <- readRDS("tmp/BRMmodel1_Fungi.rds")
model1_diet <- readRDS("tmp/BRMmodel1_diet.rds")
model1_bac <- readRDS("tmp/BRMmodel1_bac.rds")

para <- summary(model1_para)$fixed

resdf.fun<- function(model1_para, name, ASV){
    para <- summary(model1_para)$fixed
    data.frame(Domain=name,
                                            ASVs=ASV,
                genetic_dist_Estimate=para[rownames(para)=="genetic_dist", "Estimate"],
                     genetic_dist_lCI=para[rownames(para)=="genetic_dist", "l-95% CI"],
                genetic_dist_uCI=para[rownames(para)=="genetic_dist", "u-95% CI"],
                spatial_Estimate=para$Estimate[rownames(para)=="spatial"],
                     spatial_lCI=para[rownames(para)=="spatial", "l-95% CI"],
                     spatial_uCI=para[rownames(para)=="spatial", "u-95% CI"],
                                locality_Estimate=para$Estimate[rownames(para)=="locality1"],
                     locality_lCI=para[rownames(para)=="locality1", "l-95% CI"],
                     locality_uCI=para[rownames(para)=="locality1", "u-95% CI"],
                                hi_Estimate=para$Estimate[rownames(para)=="hi"],
                     hi_lCI=para[rownames(para)=="hi", "l-95% CI"],
                     hi_uCI=para[rownames(para)=="hi", "u-95% CI"],
                year_Estimate=para$Estimate[rownames(para)=="year"],
                     year_lCI=para[rownames(para)=="year", "l-95% CI"],
                     year_uCI=para[rownames(para)=="year", "u-95% CI"],
                BMI_Estimate=para$Estimate[rownames(para)=="BMI"],
                     BMI_lCI=para[rownames(para)=="BMI", "l-95% CI"],
               BMI_uCI=para[rownames(para)=="BMI", "u-95% CI"],
                               sexFM_Estimate=para$Estimate[rownames(para)=="sexFM"],
                     sexFM_lCI=para[rownames(para)=="sexFM", "l-95% CI"],
                     sexFM_uCI=para[rownames(para)=="sexFM", "u-95% CI"],
                               sexFF_Estimate=para$Estimate[rownames(para)=="sexFF"],
                     sexFF_lCI=para[rownames(para)=="sexFF", "l-95% CI"],
                     sexFF_uCI=para[rownames(para)=="sexFF", "u-95% CI"],
                               gen_hi_Estimate=para$Estimate[rownames(para)=="genetic_dist:hi"],
                     gen_hi_lCI=para[rownames(para)=="genetic_dist:hi", "l-95% CI"],
                     gen_hi_uCI=para[rownames(para)=="genetic_dist:hi", "u-95% CI"]
                )
}


Parasite

Bac

Fungi

PS.TSS

res.df <-resdf.fun(model1_para, "Parasite", 11)
res.df <- rbind(res.df, resdf.fun(model1_bac, "Bacteria", 389))
res.df <- rbind(res.df, resdf.fun(model1_diet, "Diet", 45))
res.df <- rbind(res.df, resdf.fun(model1_Fungi, "Fungi", 65))
res.df <- rbind(res.df, resdf.fun(model1, "Full model", 597))

res.df$genetic_dist_Estimate[res.df$Domain=="Full model"]

gen <- ggplot(res.df[!res.df$Domain=="Full model",], aes(x=genetic_dist_Estimate, y=Domain, colour=Domain))+
    geom_rect(aes(xmin=res.df$genetic_dist_lCI[res.df$Domain=="Full model"], xmax=res.df$genetic_dist_uCI[res.df$Domain=="Full model"], ymin=-Inf, ymax=Inf),
              fill="#cf4446", colour="white", alpha=0.05)+
    geom_errorbar(aes(xmin=genetic_dist_lCI, xmax=genetic_dist_uCI, colour=Domain), size=1, width=0.4)+
    geom_point()+
    geom_vline(xintercept=res.df$genetic_dist_Estimate[res.df$Domain=="Full model"], colour="#cf4446")+
    geom_vline(xintercept=0, linetype="dashed", linewidth=1.5)+
    scale_x_reverse()+
                                        #   scale_colour_manual(values=coul)+
#    scale_discrete_vi()+
    labs(x="Genetic distance estimate", y="")+
    theme_bw()+
    theme(legend.position = "none")
gen

spa <- ggplot(res.df[!res.df$Domain=="Full model",], aes(x=spatial_Estimate, y=Domain, colour=Domain))+
    geom_rect(aes(xmin=res.df$spatial_lCI[res.df$Domain=="Full model"], xmax=res.df$spatial_uCI[res.df$Domain=="Full model"], ymin=-Inf, ymax=Inf),
              fill="#cf4446", colour="white", alpha=0.05)+
    geom_errorbar(aes(xmin=spatial_lCI, xmax=spatial_uCI, colour=Domain), size=1, width=0.4)+
    geom_point()+
    geom_vline(xintercept=res.df$spatial_Estimate[res.df$Domain=="Full model"], colour="#cf4446")+
    geom_vline(xintercept=0, linetype="dashed", linewidth=1.5)+
    scale_x_reverse()+
                                        #   scale_colour_manual(values=coul)+
#    scale_discrete_vi()+
    labs(x="Spatial distance estimate", y="")+
    theme_bw()+
    theme(legend.position = "none")
spa

lo <- ggplot(res.df[!res.df$Domain=="Full model",], aes(x=locality_Estimate, y=Domain, colour=Domain))+
    geom_rect(aes(xmin=res.df$locality_lCI[res.df$Domain=="Full model"], xmax=res.df$locality_uCI[res.df$Domain=="Full model"], ymin=-Inf, ymax=Inf),
              fill="#cf4446", colour="white", alpha=0.05)+
    geom_errorbar(aes(xmin=locality_lCI, xmax=locality_uCI, colour=Domain), size=1, width=0.4)+
    geom_point()+
    geom_vline(xintercept=res.df$locality_Estimate[res.df$Domain=="Full model"], colour="#cf4446")+
    geom_vline(xintercept=0, linetype="dashed", linewidth=1.5)+
#    scale_x_reverse()+
                                        #   scale_colour_manual(values=coul)+
#    scale_discrete_vi()+
    labs(x="Shared locality estimate", y="")+
    theme_bw()+
    theme(legend.position = "none")
lo

hi <- ggplot(res.df[!res.df$Domain=="Full model",], aes(x=hi_Estimate, y=Domain, colour=Domain))+
    geom_rect(aes(xmin=res.df$hi_lCI[res.df$Domain=="Full model"], xmax=res.df$hi_uCI[res.df$Domain=="Full model"], ymin=-Inf, ymax=Inf),
              fill="#cf4446", colour="white", alpha=0.05)+
    geom_errorbar(aes(xmin=hi_lCI, xmax=hi_uCI, colour=Domain), size=1, width=0.4)+
    geom_point()+
    geom_vline(xintercept=res.df$hi_Estimate[res.df$Domain=="Full model"], colour="#cf4446")+
    geom_vline(xintercept=0, linetype="dashed", linewidth=1.5)+
    scale_x_reverse()+
                                        #   scale_colour_manual(values=coul)+
#    scale_discrete_vi()+
    labs(x="Hybridicity distance estimate", y="")+
    theme_bw()+
    theme(legend.position = "none")
hi

gen_hi <- ggplot(res.df[!res.df$Domain=="Full model",], aes(x=gen_hi_Estimate, y=Domain, colour=Domain))+
    geom_rect(aes(xmin=res.df$gen_hi_lCI[res.df$Domain=="Full model"], xmax=res.df$gen_hi_uCI[res.df$Domain=="Full model"], ymin=-Inf, ymax=Inf),
              fill="#cf4446", colour="white", alpha=0.05)+
    geom_errorbar(aes(xmin=gen_hi_lCI, xmax=gen_hi_uCI, colour=Domain), size=1, width=0.4)+
    geom_point()+
    geom_vline(xintercept=res.df$gen_hi_Estimate[res.df$Domain=="Full model"], colour="#cf4446")+
    geom_vline(xintercept=0, linetype="dashed", linewidth=1.5)+
#    scale_x_reverse()+
                                        #   scale_colour_manual(values=coul)+
#    scale_discrete_vi()+
    labs(x="Genetic * Hybridicity distances estimate", y="")+
    theme_bw()+
    theme(legend.position = "none")
gen_hi

year <- ggplot(res.df[!res.df$Domain=="Full model",], aes(x=year_Estimate, y=Domain, colour=Domain))+
    geom_rect(aes(xmin=res.df$year_lCI[res.df$Domain=="Full model"], xmax=res.df$year_uCI[res.df$Domain=="Full model"], ymin=-Inf, ymax=Inf),
              fill="#cf4446", colour="white", alpha=0.05)+
    geom_errorbar(aes(xmin=year_lCI, xmax=year_uCI, colour=Domain), size=1, width=0.4)+
    geom_point()+
    geom_vline(xintercept=res.df$year_Estimate[res.df$Domain=="Full model"], colour="#cf4446")+
    geom_vline(xintercept=0, linetype="dashed", linewidth=1.5)+
    scale_x_reverse()+
                                        #   scale_colour_manual(values=coul)+
#    scale_discrete_vi()+
    labs(x="Temporal distance estimate", y="")+
    theme_bw()+
    theme(legend.position = "none")
year


figure3 <- plot_grid(gen, hi, gen_hi, spa, lo, year, labels="auto", nrow=2)

figure3

ggsave("fig/figure3.pdf", figure3, width=200, height=150, units="mm", dpi=300)


